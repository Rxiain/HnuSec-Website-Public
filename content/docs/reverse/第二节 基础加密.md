# 一、数据处理
## 1.基础常识
### 位与字节
1字节(B) = 8位 (b)，范围：0x00~0xff（0~255）

二进制表示为：0000 0000 ~ 1111 1111

我们常见的算法，比如TEA，他就是要两个32位数据，也就是两个4字节的数据，而密钥是则需要4个32位数据，也就是4个4字节数据。

而这也就构成了我们常见的数据



机器字长  32位计算机：1字=32位=4字节，64位计算机：1字=64位=8字节

### 大小端序
示例：<font style="color:rgb(68, 68, 68);">32 位整数 0x12345678</font>

```python
地址   内容
0x00  0x12
0x01  0x34
0x02  0x56
0x03  0x78     //大端序

地址   内容
0x00  0x78
0x01  0x56
0x02  0x34
0x03  0x12    //小端序
```

#### 大端序(Big-Endian)：
+ **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">定义</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：高位字节存在低地址，低位字节存在高地址。</font>
+ **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">特点</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：符合人类从左到右的阅读习惯，常用于网络传输(TCP/IP)、文件格式（如BMP图片)，强调数据的重要性</font>

```python
0x12345678 (MSB -> LSB)    //Most Significant Byte, MSB
地址: 0x00 0x01 0x02 0x03
数据: 0x12 0x34 0x56 0x78
```

#### 小端序(Litttle-Endian)：
+ **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">定义</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：低位字节存在低地址，高位字节存在高地址。</font>
+ **<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">特点</font>**<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">：计算机处理效率更高（CPU直接读取低位计算），x86、ARM等常见处理器默认采用小端序</font>

```python
0x12345678 (LSB -> MSB)     //Least Significant Byte, LSB
地址: 0x00 0x01 0x02 0x03
数据: 0x78 0x56 0x34 0x12
```

### 数据填充
ZeroPaddin（零填充）

直接在结尾补00，直到达到目标字节数，用于数据达不到加密算法所需位数时。

## 2.数据获取
### 快捷键
快捷键`Shift+E`

## 3.数据分割
根据题目的算法并判断大小端序，手动或者使用函数对数据进行分割，为后续做写解密算法做准备

# 二、基础运算
因为所有的数据都是数字，而数字不正是数学吗，你能想到的所有数学运算都能对数据加密进行处理，下面就只讲几个常见的运算

## 1.异或
异或可以说是密码学中最重要的，因为其性质

A xor B xor B = A        

假如A是明文，B是密钥，我对A进行异或运算得到了密文，我再对密文使用这个密钥就能得到明文

A^B^B=A      C和python中`**^**`**表示异或**

异或的运算规则是比较两个数的二进制每一位，相同为0，不同为1

例如 

1111 0001

 xor   

0000 1111

=

1111  1110  

## 2、同或
这个也比较重要，可以用来与0xff同或来只获取数据的高位还是低位

C和python用`&`表示同或

每一位相同为1，不同为0

例如

1111 1111 &  0000 0001 = 0000 0001

用16进制表示就是 0xff &0x01=0x01

再比如 0x0f &0x15 = 0x05

## 3、位移
常见的符号为  >>右移    <<左移

运算规则如下

将为每一位向右或者左移动N位，超出边界直接舍弃

例：1001 0001 右移2  代码表示为  1001 0001 >>2 = 0010 0100

左移同理

类比科学计数法，右移N相当于数据除以 2^n，左移N相当于乘以2^N

# 三、常见加密算法
## 0.工具准备
VSCODE（写代码的）

浏览器（查资料和找工具的）

CyberChef（解密工具）

AI （自动写出代码）

## 1.异或
与基础运算同理

## 2.RC4
### 算法输入及介绍
#### 1）介绍
RC4是一种流加密，翻译过来就是用一个短的密钥生成一个长的数组再根据算法将输入的数据一个一个异或

 RC4 =  用密钥打乱一个 256 字节的状态数组 → 生成伪随机密钥流（字节序列） → 明文 ⊕ 密钥流 = 密文。  

#### 2）输入
密钥和密文都没有限制

### 算法代码
python

```python
def rc4_init(key):
    """初始化RC4状态数组"""
    S = list(range(256))
    j = 0
    # 密钥调度算法 (KSA)
    for i in range(256):
        j = (j + S[i] + key[i % len(key)]) % 256
        S[i], S[j] = S[j], S[i]  # 交换
    return S

def rc4_crypt(data,key):
    """RC4加密/解密函数"""
    S = rc4_init(key)
    i, j = 0, 0
    output=[]
    
    for byte in data:
        i = (i + 1) % 256
        j = (j + S[i]) % 256
        S[i], S[j] = S[j], S[i]  # 交换
        # 生成密钥流并异或
        k = S[(S[i] + S[j]) % 256]
        output.append(byte ^ k)
    
    return output

if __name__ == "__main__":
    key = b"SecretKey"
    text = b"Hello, RC4!"
    encrypted = rc4_crypt(text,key)
    decrypted = rc4_crypt(encrypted,key)
    for i in range(len(decrypted)):
        print(chr(decrypted[i]), end="")
```

C

```c
#include <stdio.h>
#include <string.h>

void rc4_init(unsigned char *key, unsigned char *S) {
    int i, j = 0;
    unsigned char K[256], tmp;
    int key_len = strlen((char*)key);
    
    
    // 初始化 S 和 K 数组
    for (i = 0; i < 256; i++) {
        S[i] = i;
        K[i] = key[i % key_len];
    }
    
    // 密钥调度算法 (KSA)
    for (i = 0; i < 256; i++) {
        j = (j + S[i] + K[i]) % 256;
        // 交换 S[i] 和 S[j]
        tmp = S[i];
        S[i] = S[j];
        S[j] = tmp;
    }
}

void rc4_crypt(unsigned char *data,unsigned char *key) {
    int i = 0, j = 0, k;
    int data_len = strlen((char*)data);
    unsigned char tmp;
    unsigned char S[256];
    rc4_init(key, S);
    // 伪随机生成算法 (PRGA)
    for (k = 0; k < data_len; k++) {
        i = (i + 1) % 256;
        j = (j + S[i]) % 256;
        // 交换 S[i] 和 S[j]
        tmp = S[i];
        S[i] = S[j];
        S[j] = tmp;
        // 生成密钥流字节并异或加密
        data[k] ^= S[(S[i] + S[j]) % 256];
    }
}

int main() {
    // 密钥和测试数据
    unsigned char key[] = "SecretKey";
    unsigned char text[] = "Hello, RC4!";
    int len = strlen((char*)text);   
    printf("原始数据: %s\n", text);
    // 初始化 RC4 状态数组
    // 加密（原地修改数据）
    unsigned char encrypted[256];
    memcpy(encrypted, text, len);
    rc4_crypt(encrypted,key);
    printf("加密后: ");
    for (int i = 0; i < len; i++) printf("%02X ", encrypted[i]);
    printf("\n");
    // 解密（再次异或还原数据）
    unsigned char decrypted[256];
    memcpy(decrypted, encrypted, len);
    rc4_crypt(decrypted,key);
    // 验证解密结果
    decrypted[len] = '\0'; // 添加字符串结束符
    printf("解密后: %s\n", decrypted);
    return 0;
}
```

### 算法特征
256就是这个算法的特征，只要你看到很多256，%256，还有很多交换，交换同一个数组里的数据就是RC4

实例

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/49936689/1752746742427-91236576-1c51-4bc6-a0c6-97e8c7ff459c.png)

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/49936689/1752746757463-1330ab9f-55cc-44cb-9c96-5d4f6a89f458.png)

### 算法解密
这是对称加密，直接用密钥和被加密后的算法再放进去进行处理即可

## 3.TEA
### 算法输入及介绍
#### 1）介绍
TEA是一种分组加密，所谓分组就是将输入的数据分成一分为二，让数据本身相互影响

分组长度：64 位（把明文分成左右两个 32 位）

密钥长度：128 位（4 个 32 位整数）

结构类型：Feistel 结构（左右两半轮流混合）

轮数：通常 32 轮

#### 2）输入
输入一个8字节的数据和一个16字节的密钥

其实你也可以输入两个4字节的数据和4个4字节的密钥（一般都是这样）

#### 3）算法实现
+ 把明文分成左右两部分：L 和 R
+ 每一轮用一小段密钥和一个常数（δ = 0x9E3779B9，来自黄金分割比例）
+ 通过加法、异或、移位这三种最基础的运算，把 R 混到 L 里，再把新的 L 混到 R 里
+ 重复 32 次，让两部分充分“搅拌”，达到混淆和扩散的效果

### 算法代码
一轮的典型形式：

```python
L += ((R << 4) + K0) ^ (R + sum) ^ ((R >> 5) + K1)
R += ((L << 4) + K2) ^ (L + sum) ^ ((L >> 5) + K3)
```

python：

```python
def tea_encrypt(v, k):
    v0, v1 = v
    k0, k1, k2, k3 = k
    delta = 0x9E3779B9
    total = 0
    for _ in range(32):
        total = (total + delta) & 0xFFFFFFFF
        v0 = (v0 + (((v1 << 4) + k0) ^ (v1 + total) ^ ((v1 >> 5) + k1))) & 0xFFFFFFFF
        v1 = (v1 + (((v0 << 4) + k2) ^ (v0 + total) ^ ((v0 >> 5) + k3))) & 0xFFFFFFFF
    return (v0, v1)

def tea_decrypt(v, k):
    v0, v1 = v
    k0, k1, k2, k3 = k
    delta = 0x9E3779B9
    total = (delta * 32) & 0xFFFFFFFF
    for _ in range(32):
        v1 = (v1 - (((v0 << 4) + k2) ^ (v0 + total) ^ ((v0 >> 5) + k3))) & 0xFFFFFFFF
        v0 = (v0 - (((v1 << 4) + k0) ^ (v1 + total) ^ ((v1 >> 5) + k1))) & 0xFFFFFFFF
        total = (total - delta) & 0xFFFFFFFF
    return (v0, v1)

# 示例使用
if __name__ == "__main__":
    # 密钥 (4个32位整数 = 128位)
    key = (0xA56BABCD, 0x00000000, 0xFFFFFFFF, 0xABCDEF01)
    # 明文 (2个32位整数 = 64位)
    plaintext = (0x01234567, 0x89ABCDEF)
    
    # 加密
    encrypted = tea_encrypt(plaintext, key)
    print(f"加密结果: {encrypted[0]:08X} {encrypted[1]:08X}")
    
    # 解密
    decrypted = tea_decrypt(encrypted, key)
    print(f"解密结果: {decrypted[0]:08X} {decrypted[1]:08X}")
    
```

C:

```c
#include <stdio.h>
#include <stdint.h>

void tea_encrypt(uint32_t v[2], const uint32_t k[4]) {
    uint32_t v0 = v[0], v1 = v[1];
    uint32_t sum = 0;
    const uint32_t delta = 0x9E3779B9;

    for (int i = 0; i < 32; i++) {
      
        v0 += ((v1 << 4) + k[0]) ^ (v1 + sum) ^ ((v1 >> 5) + k[1]);
        sum += delta;
        v1 += ((v0 << 4) + k[2]) ^ (v0 + sum) ^ ((v0 >> 5) + k[3]);
    }
    v[0] = v0;
    v[1] = v1;
}

void tea_decrypt(uint32_t v[2], const uint32_t k[4]) {
    uint32_t v0 = v[0], v1 = v[1];
    uint32_t sum = 0x9E3779B9 * 32;  // 等价于 delta << 5

    for (int i = 0; i < 32; i++) {
        v1 -= ((v0 << 4) + k[2]) ^ (v0 + sum) ^ ((v0 >> 5) + k[3]);
        v0 -= ((v1 << 4) + k[0]) ^ (v1 + sum) ^ ((v1 >> 5) + k[1]);
        sum -= 0x9E3779B9;
    }
    v[0] = v0;
    v[1] = v1;
}

int main() {
    // 密钥 (4个32位整数 = 128位)
    const uint32_t key[4] = {0xA56BABCD, 0x00000000, 0xFFFFFFFF, 0xABCDEF01};
    // 明文 (2个32位整数 = 64位)
    uint32_t plaintext[2] = {0x01234567, 0x89ABCDEF};

    // 加密
    tea_encrypt(plaintext, key);
    printf("加密结果: %08X %08X\n", plaintext[0], plaintext[1]);

    // 解密
    tea_decrypt(plaintext, key);
    printf("解密结果: %08X %08X\n", plaintext[0], plaintext[1]);

    return 0;
}
```

### 算法特征
实例

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/58991503/1769160872104-ee706d09-0a20-4813-9b09-5384492fe399.png)

只要你看到异或和位移， 5，*16，那肯定是TEA里的

0x9E3779B9，这个数字也算，不过如果魔改的话就不能作为依据了

### 算法解密
这样解密也几乎不用新写代码，只要将+=改为-=，并且调换第一个和第三个的位置，就相当于解密了

### 注意要点
delta=0x9E3779B9并不是固定的，delta可以为任意的数，那个位移的数在一定范围内也可任意的修改

那三个先后顺序可以随意改动

## 4.XTEA
### 算法输入及介绍
#### 1）介绍
和TEA差不多，只不过修改了密钥的使用

密钥不再是固定用 k0,k1,k2,k3，而是**随轮变化选用**。  

#### 2）输入
和TEA一样，8字节数据，16字节密钥

#### 3）典型实现
```python
for (round = 0; round < 32; round++) {
    v0 += ((v1 << 4 ^ v1 >> 5) + v1) ^ (sum + key[sum & 3]);
    sum += delta;
    v1 += ((v0 << 4 ^ v0 >> 5) + v0) ^ (sum + key[(sum >> 11) & 3]);
}
```

### 算法代码
python

```python
def xtea_encrypt(block, key):
    v0, v1 = block
    delta = 0x9E3779B9
    total = 0
    for _ in range(32):
        v0 = (v0 + (((v1 << 4 ^ v1 >> 5) + v1) ^ (total + key[total & 3])))&0xFFFFFFFF

        total = (total + delta) & 0xFFFFFFFF
        v1 = (v1 + (((v0 << 4 ^ v0 >> 5) + v0) ^ (total + key[(total >> 11) & 3])))&0xFFFFFFFF

    return (v0, v1)

def xtea_decrypt(block, key):
    v0, v1 = block
    delta = 0x9E3779B9
    total = (delta * 32) & 0xFFFFFFFF
    for _ in range(32):
        v1 = (v1 - (((v0 << 4 ^ v0 >> 5) + v0) ^ (total + key[(total >> 11) & 3])))&0xFFFFFFFF
        total = (total - delta) & 0xFFFFFFFF
        v0 = (v0 - (((v1 << 4 ^ v1 >> 5) + v1) ^ (total + key[total & 3])))&0xFFFFFFFF
    return (v0, v1)

# 示例使用
if __name__ == "__main__":
    # 128位密钥 (4个32位整数)
    key = [0xA56BABCD, 0x00000000, 0xFFFFFFFF, 0xABCDEF01]
    # 64位明文 (2个32位整数)
    plaintext = (0x01234567, 0x89ABCDEF)
    
    # 加密
    encrypted = xtea_encrypt(plaintext, key)
    print(f"加密结果: {encrypted[0]:08X} {encrypted[1]:08X}")
    
    # 解密
    decrypted = xtea_decrypt(encrypted, key)
    print(f"解密结果: {decrypted[0]:08X} {decrypted[1]:08X}")
```

C:

```c
#include <stdio.h>
#include <stdint.h>

void xtea_encrypt(uint32_t v[2], const uint32_t key[4]) {
    uint32_t v0 = v[0], v1 = v[1];
    uint32_t sum = 0;
    const uint32_t delta = 0x9E3779B9;
    
    for (int i = 0; i < 32; i++) {
        v0 += (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + key[sum & 3]);
        sum += delta;
        v1 += (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + key[(sum >> 11) & 3]);
    }
    
    v[0] = v0;
    v[1] = v1;
}

void xtea_decrypt(uint32_t v[2], const uint32_t key[4]) {
    uint32_t v0 = v[0], v1 = v[1];
    uint32_t sum = 0xC6EF3720; // 0x9E3779B9 * 32
    const uint32_t delta = 0x9E3779B9;
    
    for (int i = 0; i < 32; i++) {
        v1 -= (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + key[(sum >> 11) & 3]);
        sum -= delta;
        v0 -= (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + key[sum & 3]);
    }
    
    v[0] = v0;
    v[1] = v1;
}

int main() {
    // 128位密钥
    uint32_t key[4] = {0xA56BABCD, 0x00000000, 0xFFFFFFFF, 0xABCDEF01};
    // 64位数据块
    uint32_t data[2] = {0x01234567, 0x89ABCDEF};
    
    printf("原始数据: %08X %08X\n", data[0], data[1]);
    
    // 加密
    xtea_encrypt(data, key);
    printf("加密结果: %08X %08X\n", data[0], data[1]);
    
    // 解密
    xtea_decrypt(data, key);
    printf("解密结果: %08X %08X\n", data[0], data[1]);
    
    return 0;
}
```

### 算法特征
实例：

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/58991503/1769161607664-f4644c2c-a3d7-46fa-8ddd-8d277df0cf7b.png)

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/49936689/1752748968975-f5c2aca8-4882-48aa-9761-6a25e8415b6e.png)

先确定是TEA家族的，再看有没有两个位移的数异或

### 算法解密和要点
和TEA一模一样

## 5.XXTEA
### 算法输入及介绍
#### 1）介绍
是TEA家族里最复杂的一个

#### 2）输入
密文必须大于两个，密钥仍然是4个4字节



核心区别：

TEA / XTEA：每一轮只让“左右两个 32 位字”互相搅， 适合固定 64 位分组  

XXTEA：把整个数据块当成一个数组整体混合， 适合任意长度分组（n 个 32 位字）  

#### 3）典型实现
核心混合函数通常写为：

```c
MX = ((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (k[(p & 3) ^ e] ^ z))
```

### 算法代码
一般解密都是C的脚本，因为int 4字节，C会有溢出处理，但是python和C处理溢出的方法不一样，如果用python模拟C的溢出很麻烦

```c
#include <stdio.h>
#include <stdint.h>

#define MX (z>>5^y<<2) + (y>>3^z<<4)^(sum^y) + (k[p&3^e]^z);
//n表示数据数量
long btea(long* v, long n, long* k) {
    unsigned long z = v[n-1], y = v[0], sum = 0, e, DELTA = 0x9E3779B9;
    long p, q;
    
    if (n > 1) {         //加密
        int q_rounds = 6 + 52 / n;    //轮数通过计算得，不是固定轮数
        while (q_rounds-- > 0) {
            sum += DELTA;
            e = (sum >> 2) & 3;
            for (p = 0; p < n - 1; p++) y = v[p+1], z = v[p] += MX;
            y = v[0];
            z = v[n-1] += MX;
        }
        return 0;
    } else if (n < -1) { 
        n = -n; 			//解密
        int q_rounds = 6 + 52 / n;
        sum = q_rounds * DELTA;
        while (sum != 0) {
            e = (sum >> 2) & 3;
            for (p = n - 1; p > 0; p--) z = v[p-1], y = v[p] -= MX;
            z = v[n-1];
            y = v[0] -= MX;
            sum -= DELTA;
        }
        return 0;
    }
    return 1;
}

int main() {
    uint32_t v[2] = {0x12345678, 0x9ABCDEF0};
    uint32_t k[4] = {0x01234567, 0x89ABCDEF, 0x01234567, 0x89ABCDEF};

    btea((long*)v, 2, (long*)k);
    printf("v[0] = %08X\n", v[0]);
    printf("v[1] = %08X\n", v[1]);
    btea((long*)v, -2, (long*)k);
    printf("v[0] = %08X\n", v[0]);
    printf("v[1] = %08X\n", v[1]);

    return 0;
}
```

### 算法特征
<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2025/png/49936689/1751870099026-46669709-6393-4706-accf-a6e39afface8.png?x-oss-process=image%2Fformat%2Cwebp)

看轮数计算 52 ，异或，移位就能判断是xxtea

### 算法解密
仍然是逆序

## 6.Z3
### 介绍
z3求解器多用于线性数学问题的求解

### 安装
`pip install z3-solver`

### 基础使用
#### 常用函数
1. s=solver()，创建一个解的对象。
2. s.add(条件)，为解增加一个限制条件
3. s.check()，检查解是否存在，如果存在，会返回"sat"
4. model()，输出解得结果

### 示例
```python
import z3

x = [0] * 6
for i in range(6):
    x[i] = z3.Int('x[' + str(i) + ']')

s = z3.Solver()               #创建一个z3的实例
s.add(x[0] == 0xDF48EF7E)
s.add(x[5] == 0x84F30420)
s.add(x[1] == 0x20CAACF4)
s.add(x[2]-x[3] == 0x84A236FF)
s.add(x[3]+x[4] == 0xFA6CB703)
s.add(x[2]-x[4] == 0x42D731A8)

if s.check() == z3.sat:     #必须要验证是否有解
    print(s.model())        #使用model来求解
else:
    raise Exception("NO SOLUTION!")


#例：v, w, x, y, z = z3.Ints('v w x y z')    #必须写成z3中的变量类型
```

## 7.base64编码
### 介绍
 Base64 的作用： 把任意二进制数据，用64 个可打印字符来表示，方便在网络、邮件、文本协议中传输。  

### 编码实现
base64编码每3个字节映射到4个字符

1. 每 3 个字节拼成 24 位二进制
2.  切成 4 组，每组 6 位  
3.  每个 6 位数查一张固定的表（码表）

### 特征
末尾有 `=` 或 `==`，高度怀疑是 Base64

只包含 `A–Z a–z 0–9 + /`，基本就是 Base64

实例：

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/58991503/1769163362384-23806994-3ca7-4ed8-ac96-6678b6f822c3.png)

TlNTQ1RGe2Jhc2VfNjRfTlRXUTRaR0ROQzdOfQ==

### 解密
一般直接搜索工具即可

