#### <font style="color:rgb(31, 31, 31);"> 1.1.1ELF 可执行文件格式与内存布局</font>
<font style="color:rgb(31, 31, 31);">在 Linux 系统中，二进制程序通常以 ELF（Executable and Linkable Format）格式存在。当一个 ELF 文件被加载到内存中运行时，它会映射为特定的虚拟内存布局。理解这一布局是理解溢出的前提 </font><font style="color:rgb(31, 31, 31);">。</font>

+ **<font style="color:rgb(31, 31, 31);">代码段（.text）</font>**<font style="color:rgb(31, 31, 31);">：存放 CPU 执行的机器指令。通常是只读的（Read-Only）和可执行的（Executable）。如果攻击者能够将指令指针（RIP）指向这里，CPU 就会忠实地执行其中的代码。</font>
+ **<font style="color:rgb(31, 31, 31);">数据段（.data）</font>**<font style="color:rgb(31, 31, 31);">：存放已初始化的全局变量和静态变量。</font>
+ **<font style="color:rgb(31, 31, 31);">BSS 段（.bss）</font>**<font style="color:rgb(31, 31, 31);">：存放未初始化的全局变量。在程序加载时，这块内存会被清零。由于它通常是可读写的，常被利用于存放攻击者构造的数据。</font>
+ **<font style="color:rgb(31, 31, 31);">堆（Heap）</font>**<font style="color:rgb(31, 31, 31);">：用于动态内存分配（如 </font>`<font style="color:rgb(68, 71, 70);">malloc</font>`<font style="color:rgb(31, 31, 31);">）。堆从低地址向高地址增长。</font>
+ **<font style="color:rgb(31, 31, 31);">栈（Stack）</font>**<font style="color:rgb(31, 31, 31);">：这是栈溢出攻击的核心区域。用于存放局部变量、函数参数和函数返回地址。栈的增长方向与堆相反，是从</font>**<font style="color:rgb(31, 31, 31);">高地址向低地址</font>**<font style="color:rgb(31, 31, 31);">增长 </font><font style="color:rgb(31, 31, 31);">。</font>

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/webp/58878864/1769219011600-a1bc2d55-265f-4f43-9f49-6f75461fe187.webp)

#### <font style="color:rgb(31, 31, 31);">1.1.2 寄存器架构（x86 与 x86-64）</font>
<font style="color:rgb(31, 31, 31);">寄存器是 CPU 内部极其高速的存储单元，是数据处理和指令执行的直接场所。在 Pwn 中，我们主要关注通用寄存器和特殊寄存器。目前主流的架构分为 32 位（x86）和 64 位（x86-64/AMD64）。</font>

**<font style="color:rgb(31, 31, 31);">通用寄存器及其用途：</font>**

| **<font style="color:rgb(31, 31, 31);">64位寄存器 (8字节)</font>** | **<font style="color:rgb(31, 31, 31);">32位寄存器 (4字节)</font>** | **<font style="color:rgb(31, 31, 31);">主要用途</font>** |
| --- | --- | --- |
| **<font style="color:rgb(31, 31, 31);">RAX</font>** | <font style="color:rgb(31, 31, 31);">EAX</font> | **<font style="color:rgb(31, 31, 31);">累加器</font>**<font style="color:rgb(31, 31, 31);">。通常用于存储函数的返回值。在系统调用（Syscall）中存储调用号。</font> |
| **<font style="color:rgb(31, 31, 31);">RBX</font>** | <font style="color:rgb(31, 31, 31);">EBX</font> | **<font style="color:rgb(31, 31, 31);">基址寄存器</font>**<font style="color:rgb(31, 31, 31);">。通常作为数据指针。</font> |
| **<font style="color:rgb(31, 31, 31);">RCX</font>** | <font style="color:rgb(31, 31, 31);">ECX</font> | **<font style="color:rgb(31, 31, 31);">计数寄存器</font>**<font style="color:rgb(31, 31, 31);">。常用于循环计数。在 64 位函数调用中作为第 4 个参数。</font> |
| **<font style="color:rgb(31, 31, 31);">RDX</font>** | <font style="color:rgb(31, 31, 31);">EDX</font> | **<font style="color:rgb(31, 31, 31);">数据寄存器</font>**<font style="color:rgb(31, 31, 31);">。常配合 RAX 进行运算。在 64 位函数调用中作为第 3 个参数。</font> |
| **<font style="color:rgb(31, 31, 31);">RSI</font>** | <font style="color:rgb(31, 31, 31);">ESI</font> | **<font style="color:rgb(31, 31, 31);">源变址寄存器</font>**<font style="color:rgb(31, 31, 31);">。常用于字符串操作。在 64 位函数调用中作为第 2 个参数。</font> |
| **<font style="color:rgb(31, 31, 31);">RDI</font>** | <font style="color:rgb(31, 31, 31);">EDI</font> | **<font style="color:rgb(31, 31, 31);">目的变址寄存器</font>**<font style="color:rgb(31, 31, 31);">。常用于字符串操作。在 64 位函数调用中作为 </font>**<font style="color:rgb(31, 31, 31);">第 1 个参数</font>**<font style="color:rgb(31, 31, 31);">。</font> |
| **<font style="color:rgb(31, 31, 31);">RBP</font>** | <font style="color:rgb(31, 31, 31);">EBP</font> | **<font style="color:rgb(31, 31, 31);">基址指针寄存器</font>**<font style="color:rgb(31, 31, 31);">。指向当前栈帧（Stack Frame）的底部，是栈操作的基准点 </font><font style="color:rgb(31, 31, 31);">。</font> |
| **<font style="color:rgb(31, 31, 31);">RSP</font>** | <font style="color:rgb(31, 31, 31);">ESP</font> | **<font style="color:rgb(31, 31, 31);">栈指针寄存器</font>**<font style="color:rgb(31, 31, 31);">。始终指向栈顶，随着 Push/Pop 操作动态变化 </font><font style="color:rgb(31, 31, 31);">。</font> |
| **<font style="color:rgb(31, 31, 31);">RIP</font>** | <font style="color:rgb(31, 31, 31);">EIP</font> | **<font style="color:rgb(31, 31, 31);">指令指针寄存器</font>**<font style="color:rgb(31, 31, 31);">。存放</font>**<font style="color:rgb(31, 31, 31);">下一条</font>**<font style="color:rgb(31, 31, 31);">即将执行指令的地址。这是攻击者的终极目标——控制了 RIP 就控制了程序的执行流 </font><font style="color:rgb(31, 31, 31);">。</font> |
| **<font style="color:rgb(31, 31, 31);">R8 - R15</font>** | <font style="color:rgb(31, 31, 31);">N/A</font> | <font style="color:rgb(31, 31, 31);">64 位架构新增的通用寄存器。</font> |


**<font style="color:rgb(31, 31, 31);">重要差异：函数调用约定（Calling Convention）</font>**

+ **<font style="color:rgb(31, 31, 31);">x86 (32位)</font>**<font style="color:rgb(31, 31, 31);">：函数参数通过</font>**<font style="color:rgb(31, 31, 31);">栈</font>**<font style="color:rgb(31, 31, 31);">传递。参数从右向左压栈，最后压入返回地址。</font>
+ **<font style="color:rgb(31, 31, 31);">x64 (64位)</font>**<font style="color:rgb(31, 31, 31);">：前 6 个参数依次通过寄存器 </font>**<font style="color:rgb(31, 31, 31);">RDI, RSI, RDX, RCX, R8, R9</font>**<font style="color:rgb(31, 31, 31);"> 传递。超过 6 个的参数才通过栈传递 </font><font style="color:rgb(31, 31, 31);">。</font>
+ <font style="color:rgb(31, 31, 31);">这一差异直接决定了我们在构造攻击载荷（Payload）时的策略。在 64 位系统中，仅仅覆盖栈上的数据不足以控制函数参数，我们必须想办法操作寄存器，这通常需要 ROP 技术。</font>

#### <font style="color:rgb(31, 31, 31);">1.2.3 关键汇编指令</font>
+ `<font style="color:rgb(68, 71, 70);">MOV dest, src</font>`<font style="color:rgb(31, 31, 31);">：数据传送。将 src 的内容复制到 dest。</font>
+ `<font style="color:rgb(68, 71, 70);">PUSH src</font>`<font style="color:rgb(31, 31, 31);">：压栈。先将 RSP 减小（因为栈向低地址增长），然后将 src 的值存入 RSP 指向的内存 </font><font style="color:rgb(31, 31, 31);">。</font>
    - `<font style="color:rgb(68, 71, 70);">RSP = RSP - 8</font>`
    - `<font style="color:rgb(68, 71, 70);">*RSP = src</font>`
+ `<font style="color:rgb(68, 71, 70);">POP dest</font>`<font style="color:rgb(31, 31, 31);">：出栈。将 RSP 指向的内存值读入 dest，然后将 RSP 增大。</font>
    - `<font style="color:rgb(68, 71, 70);">dest = *RSP</font>`
    - `<font style="color:rgb(68, 71, 70);">RSP = RSP + 8</font>`
+ `<font style="color:rgb(68, 71, 70);">LEAVE</font>`<font style="color:rgb(31, 31, 31);">：恢复栈帧。等价于 </font>`<font style="color:rgb(68, 71, 70);">MOV RSP, RBP</font>`<font style="color:rgb(31, 31, 31);"> 然后 </font>`<font style="color:rgb(68, 71, 70);">POP RBP</font>`<font style="color:rgb(31, 31, 31);">。用于函数退出前清理现场。</font>
+ `<font style="color:rgb(68, 71, 70);">RET</font>`<font style="color:rgb(31, 31, 31);">：返回。等价于 </font>`<font style="color:rgb(68, 71, 70);">POP RIP</font>`<font style="color:rgb(31, 31, 31);">。这是栈溢出利用的“引爆点”。它从栈顶弹出一个值赋给 RIP，CPU 接着跳转到该地址执行。如果栈顶的值被攻击者修改为恶意地址，攻击就生效了 </font><font style="color:rgb(31, 31, 31);">。</font>

#### <font style="color:rgb(31, 31, 31);">1.2.4 字节序（Endianness）</font>
<font style="color:rgb(31, 31, 31);">在内存中存储多字节数据（如 64 位的地址）时，有两种顺序：</font>

+ **<font style="color:rgb(31, 31, 31);">大端序（Big-Endian）</font>**<font style="color:rgb(31, 31, 31);">：高位字节存放在低地址。</font>
+ **<font style="color:rgb(31, 31, 31);">小端序（Little-Endian）</font>**<font style="color:rgb(31, 31, 31);">：低位字节存放在低地址。x86/x64 架构使用小端序。 例如，地址 </font>`<font style="color:rgb(68, 71, 70);">0x7fffffffe4b0</font>`<font style="color:rgb(31, 31, 31);"> 在内存中存放的顺序是 </font>`<font style="color:rgb(68, 71, 70);">b0 e4 ff ff ff 7f 00 00</font>`<font style="color:rgb(31, 31, 31);">。在编写 Python 攻击脚本时，我们需要使用 </font>`<font style="color:rgb(68, 71, 70);">p64()</font>`<font style="color:rgb(31, 31, 31);"> 函数将数值转换为这种小端序的字节流 </font><font style="color:rgb(31, 31, 31);">。</font>

---

## <font style="color:rgb(31, 31, 31);">2. 深入理解栈数据结构与内存布局</font>
<font style="color:rgb(31, 31, 31);">为什么会有“栈溢出”？要回答这个问题，必须深入理解栈在函数调用过程中的生命周期。栈不仅仅是一块内存，它是维护程序逻辑上下文（Context）的核心数据结构 </font><font style="color:rgb(31, 31, 31);">。</font>

```bash
                                           +-----------------+
                                           |     retaddr     |
                                           +-----------------+
                                           |     saved ebp   |
                                    ebp--->+-----------------+
                                           |                 |
                                           |                 |
                                           |                 |
                                           |                 |
                                           |                 |
                                           |                 |
                              s,ebp-0x14-->+-----------------+
```

栈的简单结构

### <font style="color:rgb(31, 31, 31);">2.1 栈的动态变化：函数调用全过程</font>
<font style="color:rgb(31, 31, 31);">当一个函数（Caller）调用另一个函数（Callee）时，栈会发生一系列精确的操作来保存现场，以便 Callee 执行完毕后能回到 Caller 继续执行。这个过程称为“栈帧的建立与销毁”。</font>

**<font style="color:rgb(31, 31, 31);">Step 1: 参数入栈（32位）或 寄存器赋值（64位）</font>**

<font style="color:rgb(31, 31, 31);">在调用发生前，参数被准备好。</font>

**<font style="color:rgb(31, 31, 31);">Step 2: 保存返回地址（The Return Address）</font>**<font style="color:rgb(31, 31, 31);"> 执行 </font>`<font style="color:rgb(68, 71, 70);">call func</font>`<font style="color:rgb(31, 31, 31);"> 指令时，CPU 会自动将 </font>`<font style="color:rgb(68, 71, 70);">call</font>`<font style="color:rgb(31, 31, 31);"> 指令的</font>**<font style="color:rgb(31, 31, 31);">下一条指令地址</font>**<font style="color:rgb(31, 31, 31);">压入栈顶。这个地址就是“返回地址”。这是攻击者梦寐以求想要覆盖的数据 </font><font style="color:rgb(31, 31, 31);">。</font>

**<font style="color:rgb(31, 31, 31);">Step 3: 保存调用者的基址指针（Saved RBP）</font>**

<font style="color:rgb(31, 31, 31);">进入 Callee 后，第一件事通常是保存 Caller 的 RBP，以便后续恢复。</font>

<font style="color:rgb(68, 71, 70);">Đoạn mã</font>

```z80
push rbp
```

**<font style="color:rgb(31, 31, 31);">Step 4: 建立新的栈帧（Set up Stack Frame）</font>**

<font style="color:rgb(31, 31, 31);">将当前的 RSP 赋值给 RBP，标志着新栈帧的开始。</font>

```z80
mov rbp, rsp
```

<font style="color:rgb(31, 31, 31);">此时，RBP 指向当前栈帧的“底部”（虽然物理地址较高）。</font>

**<font style="color:rgb(31, 31, 31);">Step 5: 分配局部变量空间</font>**

<font style="color:rgb(31, 31, 31);">将 RSP 减去一个数值，为局部变量腾出空间。</font>

```z80
sub rsp, 0x40  ; 分配 64 字节空间
```

**<font style="color:rgb(31, 31, 31);">此时栈的布局（从高地址到低地址）：</font>**

| **<font style="color:rgb(31, 31, 31);">内存内容</font>** | **<font style="color:rgb(31, 31, 31);">说明</font>** | **<font style="color:rgb(31, 31, 31);">攻击价值</font>** |
| --- | --- | --- |
| **<font style="color:rgb(31, 31, 31);">Arguments</font>** | <font style="color:rgb(31, 31, 31);">函数参数（32位）</font> | <font style="color:rgb(31, 31, 31);">影响函数逻辑</font> |
| **<font style="color:rgb(31, 31, 31);">Return Address</font>** | <font style="color:rgb(31, 31, 31);">返回地址（8字节）</font> | **<font style="color:rgb(31, 31, 31);">最高价值</font>**<font style="color:rgb(31, 31, 31);">。控制执行流</font> |
| **<font style="color:rgb(31, 31, 31);">Saved RBP</font>** | <font style="color:rgb(31, 31, 31);">保存的旧 RBP（8字节）</font> | <font style="color:rgb(31, 31, 31);">影响栈迁移（Stack Pivot）</font> |
| **<font style="color:rgb(31, 31, 31);">Local Variables</font>** | <font style="color:rgb(31, 31, 31);">局部变量缓冲区（如 char buf）</font> | **<font style="color:rgb(31, 31, 31);">溢出起点</font>**<font style="color:rgb(31, 31, 31);">。注入数据</font> |
| **<font style="color:rgb(31, 31, 31);">Top of Stack</font>** | <font style="color:rgb(31, 31, 31);">RSP 指向此处</font> | |


### <font style="color:rgb(31, 31, 31);">2.2 为什么会有栈溢出漏洞？</font>
<font style="color:rgb(31, 31, 31);">C 语言的设计哲学是“信任程序员”和“追求性能”。标准库中的许多字符串处理函数（如 </font>`<font style="color:rgb(68, 71, 70);">strcpy</font>`<font style="color:rgb(31, 31, 31);">, </font>`<font style="color:rgb(68, 71, 70);">gets</font>`<font style="color:rgb(31, 31, 31);">, </font>`<font style="color:rgb(68, 71, 70);">strcat</font>`<font style="color:rgb(31, 31, 31);">）在复制数据时，</font>**<font style="color:rgb(31, 31, 31);">不检查目标缓冲区的大小</font>**<font style="color:rgb(31, 31, 31);">。</font>

<font style="color:rgb(31, 31, 31);">假设源代码如下：</font>

```c
void vulnerable_function() {
    char buffer;
    gets(buffer); // 危险！
}
```

<font style="color:rgb(31, 31, 31);">gets函数 会一直读取用户输入，直到遇到换行符。如果用户输入了 100 个 'A'：</font>

1. <font style="color:rgb(31, 31, 31);">前 64 个 'A' 填满了 </font>`<font style="color:rgb(68, 71, 70);">buffer</font>`<font style="color:rgb(31, 31, 31);">。</font>
2. <font style="color:rgb(31, 31, 31);">接下来的 8 个 'A' 覆盖了 </font>**<font style="color:rgb(31, 31, 31);">Saved RBP</font>**<font style="color:rgb(31, 31, 31);">。</font>
3. <font style="color:rgb(31, 31, 31);">再接下来的 8 个 'A' 覆盖了 </font>**<font style="color:rgb(31, 31, 31);">Return Address</font>**<font style="color:rgb(31, 31, 31);">。</font>
4. <font style="color:rgb(31, 31, 31);">剩余的 'A' 继续向高地址覆盖。</font>

<font style="color:rgb(31, 31, 31);">当 </font>`<font style="color:rgb(68, 71, 70);">vulnerable_function</font>`<font style="color:rgb(31, 31, 31);"> 执行完毕，运行到 </font>`<font style="color:rgb(68, 71, 70);">ret</font>`<font style="color:rgb(31, 31, 31);"> 指令时，CPU 会执行 </font>`<font style="color:rgb(68, 71, 70);">pop rip</font>`<font style="color:rgb(31, 31, 31);">。此时栈顶的值已经被我们覆盖成了 </font>`<font style="color:rgb(68, 71, 70);">0x4141414141414141</font>`<font style="color:rgb(31, 31, 31);">（'A' 的 ASCII 码）。CPU 试图跳转到这个地址去执行指令。由于这是一个无效地址，程序通常会报“段错误”（Segmentation Fault）并崩溃。但如果我们精心构造，将这里的 'A' 换成一个合法的代码地址，CPU 就会跳转过去执行，这就完成了攻击 </font><font style="color:rgb(31, 31, 31);">。</font>

---

## <font style="color:rgb(31, 31, 31);">3. 动态调试与分析艺术</font>
<font style="color:rgb(31, 31, 31);">假设我们有一个名为 </font>`<font style="color:rgb(68, 71, 70);">vuln</font>`<font style="color:rgb(31, 31, 31);"> 的可执行文件。</font>

+ `<font style="color:rgb(68, 71, 70);">gdb./vuln</font>`<font style="color:rgb(31, 31, 31);">：启动调试。</font>
+ `<font style="color:rgb(68, 71, 70);">checksec</font>`<font style="color:rgb(31, 31, 31);">：(Pwndbg ) 检查二进制文件的保护机制（NX, Canary, PIE, RELRO）。</font>
+ `<font style="color:rgb(68, 71, 70);">run</font>`<font style="color:rgb(31, 31, 31);"> (或 </font>`<font style="color:rgb(68, 71, 70);">r</font>`<font style="color:rgb(31, 31, 31);">)：开始运行程序。</font>
+ `<font style="color:rgb(68, 71, 70);">break *0x401123</font>`<font style="color:rgb(31, 31, 31);"> (或 </font>`<font style="color:rgb(68, 71, 70);">b</font>`<font style="color:rgb(31, 31, 31);">)：在特定内存地址下断点。</font>
+ `<font style="color:rgb(68, 71, 70);">next</font>`<font style="color:rgb(31, 31, 31);"> (或 </font>`<font style="color:rgb(68, 71, 70);">n</font>`<font style="color:rgb(31, 31, 31);">)：单步步过（不进入函数）。</font>
+ `<font style="color:rgb(68, 71, 70);">step</font>`<font style="color:rgb(31, 31, 31);"> (或 </font>`<font style="color:rgb(68, 71, 70);">s</font>`<font style="color:rgb(31, 31, 31);">)：单步步入（进入函数）。</font>
+ `<font style="color:rgb(68, 71, 70);">continue</font>`<font style="color:rgb(31, 31, 31);"> (或 </font>`<font style="color:rgb(68, 71, 70);">c</font>`<font style="color:rgb(31, 31, 31);">)：继续执行直到下一个断点。</font>
+ `<font style="color:rgb(68, 71, 70);">x/20gx $rsp</font>`<font style="color:rgb(31, 31, 31);">：查看栈内存。</font>
    - `<font style="color:rgb(68, 71, 70);">x</font>`<font style="color:rgb(31, 31, 31);">：Examine（检查）。</font>
    - `<font style="color:rgb(68, 71, 70);">20</font>`<font style="color:rgb(31, 31, 31);">：显示 20 个单位。</font>
    - `<font style="color:rgb(68, 71, 70);">g</font>`<font style="color:rgb(31, 31, 31);">：Giant word（8字节，64位系统常用）。</font>
    - `<font style="color:rgb(68, 71, 70);">x</font>`<font style="color:rgb(31, 31, 31);">：以十六进制显示。</font>
    - `<font style="color:rgb(68, 71, 70);">$rsp</font>`<font style="color:rgb(31, 31, 31);">：从 RSP 指向的地址开始。</font>
+ `<font style="color:rgb(68, 71, 70);">info registers</font>`<font style="color:rgb(31, 31, 31);"> (或 </font>`<font style="color:rgb(68, 71, 70);">i r</font>`<font style="color:rgb(31, 31, 31);">)：查看所有寄存器的值。</font>
+ `<font style="color:rgb(68, 71, 70);">disassemble main</font>`<font style="color:rgb(31, 31, 31);">：反汇编 main 函数代码。</font>

### <font style="color:rgb(31, 31, 31);">确定溢出偏移（Offset）</font>
<font style="color:rgb(31, 31, 31);">这是利用栈溢出的第一步：我们需要确切地知道，填充多少字节的垃圾数据，才能刚好触碰到 Return Address </font><font style="color:rgb(31, 31, 31);">。</font>

**<font style="color:rgb(31, 31, 31);">方法一：手动计算</font>**

<font style="color:rgb(31, 31, 31);">通过 IDA Pro 或 Ghidra 反编译，查看缓冲区相对于 RBP 的偏移。</font>

<font style="color:rgb(31, 31, 31);">例如：</font>`<font style="color:rgb(68, 71, 70);">char buf</font>`<font style="color:rgb(31, 31, 31);"> 通常在 </font>`<font style="color:rgb(68, 71, 70);">rbp-0x40</font>`<font style="color:rgb(31, 31, 31);">。</font>

<font style="color:rgb(31, 31, 31);">返回地址在 </font>`<font style="color:rgb(68, 71, 70);">rbp+0x8</font>`<font style="color:rgb(31, 31, 31);">。</font>

<font style="color:rgb(31, 31, 31);">所以偏移量 = 0x40 (64) + 0x8 (Saved RBP 8字节) = 72 字节。</font>

**<font style="color:rgb(31, 31, 31);">方法二：Cyclic Pattern（动态测量）</font>**

<font style="color:rgb(31, 31, 31);">这是更通用的方法。Pwntools 提供了一个工具 </font>`<font style="color:rgb(68, 71, 70);">cyclic</font>`<font style="color:rgb(31, 31, 31);">，生成特定规律的字符串（De Bruijn 序列）。</font>

1. <font style="color:rgb(31, 31, 31);">生成 100 字节的 Pattern：</font>

```bash
cyclic 100
# 输出: aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama...
```

2. <font style="color:rgb(31, 31, 31);">在 GDB 中运行程序，输入该字符串。</font>
3. <font style="color:rgb(31, 31, 31);">程序崩溃。查看崩溃时的栈顶或 RIP 寄存器。</font>
    - <font style="color:rgb(31, 31, 31);">在 64 位系统中，程序通常会在 </font>`<font style="color:rgb(68, 71, 70);">ret</font>`<font style="color:rgb(31, 31, 31);"> 指令处崩溃，因为弹出的地址无效。此时查看栈顶的值。</font>
    - <font style="color:rgb(31, 31, 31);">假设 GDB 显示栈顶（RSP）的值为 </font>`<font style="color:rgb(68, 71, 70);">0x6161616c</font>`<font style="color:rgb(31, 31, 31);">（对应字符 'laaa'）。</font>
4. <font style="color:rgb(31, 31, 31);">计算偏移：</font>

```bash
cyclic -l 0x6161616c
# 输出: 72
```

<font style="color:rgb(31, 31, 31);">这意味着我们需要 72 个字节的填充，第 73-80 个字节将覆盖 Return Address </font><font style="color:rgb(31, 31, 31);">。</font>

---

## <font style="color:rgb(31, 31, 31);">4. 基础防护机制概览</font>
<font style="color:rgb(31, 31, 31);">在开始实战前，必须看懂 </font>`<font style="color:rgb(68, 71, 70);">checksec</font>`<font style="color:rgb(31, 31, 31);"> 的输出，这决定了我们的攻击路径 </font><font style="color:rgb(31, 31, 31);">。</font>

1. **<font style="color:rgb(31, 31, 31);">Arch (架构)</font>**<font style="color:rgb(31, 31, 31);">: x86 或 amd64。决定了寄存器大小和系统调用方式。</font>
2. **<font style="color:rgb(31, 31, 31);">RELRO (Relocation Read-Only)</font>**<font style="color:rgb(31, 31, 31);">:</font>
    - <font style="color:rgb(31, 31, 31);">No RELRO: GOT 表可写。</font>
    - <font style="color:rgb(31, 31, 31);">Partial RELRO: GOT 表可写（常见）。</font>
    - <font style="color:rgb(31, 31, 31);">Full RELRO: GOT 表只读，无法修改 GOT 表劫持函数调用。</font>
3. **<font style="color:rgb(31, 31, 31);">Stack Canary (栈哨兵)</font>**<font style="color:rgb(31, 31, 31);">:</font>
    - <font style="color:rgb(31, 31, 31);">Enabled: 栈中插入了校验值，防止连续覆盖。</font>
    - <font style="color:rgb(31, 31, 31);">Disabled: 可以随意溢出。</font>
4. **<font style="color:rgb(31, 31, 31);">NX (No-Execute) / DEP</font>**<font style="color:rgb(31, 31, 31);">:</font>
    - <font style="color:rgb(31, 31, 31);">Enabled: 栈和堆不可执行。无法直接运行 Shellcode，必须使用 ROP。</font>
    - <font style="color:rgb(31, 31, 31);">Disabled: 栈可执行。可以直接跳到栈上执行 Shellcode。</font>
5. **<font style="color:rgb(31, 31, 31);">PIE (Position Independent Executable)</font>**<font style="color:rgb(31, 31, 31);">:</font>
    - <font style="color:rgb(31, 31, 31);">Enabled: 代码段地址随机化。不知道函数地址。</font>
    - <font style="color:rgb(31, 31, 31);">Disabled: 代码段地址固定。可以直接硬编码函数地址。</font>

---

## <font style="color:rgb(31, 31, 31);">5. 实战演练 I：Ret2Text（有后门的程序）</font>
<font style="color:rgb(31, 31, 31);">这是最简单的场景。目标程序中存在一个 </font>`<font style="color:rgb(68, 71, 70);">win()</font>`<font style="color:rgb(31, 31, 31);"> 或 </font>`<font style="color:rgb(68, 71, 70);">backdoor()</font>`<font style="color:rgb(31, 31, 31);"> 函数，能直接给 Shell 或打印 Flag，但正常逻辑不会调用它。我们要做的就是把 </font>`<font style="color:rgb(68, 71, 70);">main</font>`<font style="color:rgb(31, 31, 31);"> 函数的返回地址改为 </font>`<font style="color:rgb(68, 71, 70);">win</font>`<font style="color:rgb(31, 31, 31);"> 函数的地址。</font>

**<font style="color:rgb(31, 31, 31);">题目特征</font>**<font style="color:rgb(31, 31, 31);">：</font>

+ <font style="color:rgb(31, 31, 31);">Stack Overflow 漏洞存在（如 </font>`<font style="color:rgb(68, 71, 70);">gets</font>`<font style="color:rgb(31, 31, 31);">）。</font>
+ **<font style="color:rgb(31, 31, 31);">NX Enabled</font>**<font style="color:rgb(31, 31, 31);"> (无所谓，因为利用的是程序自带代码)。</font>
+ **<font style="color:rgb(31, 31, 31);">PIE Disabled</font>**<font style="color:rgb(31, 31, 31);"> (关键，地址固定)。</font>
+ **<font style="color:rgb(31, 31, 31);">Canary Disabled</font>**<font style="color:rgb(31, 31, 31);">。</font>

### <font style="color:rgb(31, 31, 31);">5.1 攻击步骤</font>
1. **<font style="color:rgb(31, 31, 31);">静态分析</font>**<font style="color:rgb(31, 31, 31);">：使用 IDA/Ghidra 或 </font>`<font style="color:rgb(68, 71, 70);">objdump -d./pwn | grep win</font>`<font style="color:rgb(31, 31, 31);"> 找到 </font>`<font style="color:rgb(68, 71, 70);">win</font>`<font style="color:rgb(31, 31, 31);"> 函数的地址。假设为 </font>`<font style="color:rgb(68, 71, 70);">0x401176</font>`<font style="color:rgb(31, 31, 31);">。</font>
2. **<font style="color:rgb(31, 31, 31);">动态调试</font>**<font style="color:rgb(31, 31, 31);">：使用 </font>`<font style="color:rgb(68, 71, 70);">cyclic</font>`<font style="color:rgb(31, 31, 31);"> 测出溢出偏移量。假设为 40。</font>
3. **<font style="color:rgb(31, 31, 31);">编写脚本</font>**<font style="color:rgb(31, 31, 31);">：使用 Pwntools。</font>

### <font style="color:rgb(31, 31, 31);">5.2 Pwntools 脚本示例</font>
<font style="color:rgb(68, 71, 70);">Python</font>

```python
from pwn import *

# 1. 设置目标架构
context.arch = 'amd64'
context.log_level = 'debug'

# 2. 启动进程
p = process('./ret2text_challenge')
# p = remote('ip', port) # 远程连接

# 3. 准备数据
offset = 40
win_addr = 0x401176

# 4. 构造 Payload
# b'A' * 40 填充缓冲区和 Saved RBP
# p64(win_addr) 将地址打包成 8 字节小端序
payload = b'A' * offset + p64(win_addr)

# 5. 发送 Payload
p.sendline(payload)

# 6. 交互
p.interactive()
```

### <font style="color:rgb(31, 31, 31);">5.3 栈对齐（Stack Alignment）</font>
<font style="color:rgb(31, 31, 31);">在 Ubuntu 18.04 及更高版本的 64 位系统中，调用 </font>`<font style="color:rgb(68, 71, 70);">system</font>`<font style="color:rgb(31, 31, 31);"> 或 </font>`<font style="color:rgb(68, 71, 70);">printf</font>`<font style="color:rgb(31, 31, 31);"> 等库函数时，要求栈顶指针 RSP 必须是 </font>**<font style="color:rgb(31, 31, 31);">16 字节对齐</font>**<font style="color:rgb(31, 31, 31);">的（即 RSP 的末尾必须是 0）。如果直接跳转到 </font>`<font style="color:rgb(68, 71, 70);">win</font>`<font style="color:rgb(31, 31, 31);"> 函数，且 </font>`<font style="color:rgb(68, 71, 70);">win</font>`<font style="color:rgb(31, 31, 31);"> 函数第一条指令就是调用 </font>`<font style="color:rgb(68, 71, 70);">system</font>`<font style="color:rgb(31, 31, 31);">，可能会因为栈未对齐而导致 </font>`<font style="color:rgb(68, 71, 70);">movaps</font>`<font style="color:rgb(31, 31, 31);"> 指令崩溃（Segfault）</font><font style="color:rgb(31, 31, 31);">。</font>

**<font style="color:rgb(31, 31, 31);">解决方案</font>**<font style="color:rgb(31, 31, 31);">：在跳转到 </font>`<font style="color:rgb(68, 71, 70);">win</font>`<font style="color:rgb(31, 31, 31);"> 之前，先跳转到一个 </font>`<font style="color:rgb(68, 71, 70);">ret</font>`<font style="color:rgb(31, 31, 31);"> 指令（Ret Gadget）。</font>

`<font style="color:rgb(68, 71, 70);">ret</font>`<font style="color:rgb(31, 31, 31);"> 指令相当于 </font>`<font style="color:rgb(68, 71, 70);">pop rip</font>`<font style="color:rgb(31, 31, 31);">，会把 RSP 增加 8。这样原本不对应 16 的 RSP 就可能对齐了。</font>

<font style="color:rgb(31, 31, 31);">Payload 变为：</font>`<font style="color:rgb(68, 71, 70);">Padding + p64(ret_gadget) + p64(win_addr)</font>`<font style="color:rgb(31, 31, 31);">。</font>

---

## <font style="color:rgb(31, 31, 31);">6. 实战演练 II：Shellcode 生成与利用（NX Disabled）</font>
**<font style="color:rgb(31, 31, 31);">场景</font>**<font style="color:rgb(31, 31, 31);">：程序没有后门函数，但是关闭了 NX 保护（Stack Executable）。 </font>**<font style="color:rgb(31, 31, 31);">目标</font>**<font style="color:rgb(31, 31, 31);">：将自己编写的机器码（Shellcode）注入栈中，并控制 RIP 跳转到栈上执行它 </font><font style="color:rgb(31, 31, 31);">。</font>

### <font style="color:rgb(31, 31, 31);">6.1 什么是 Shellcode？</font>
<font style="color:rgb(31, 31, 31);">Shellcode 是一段用于启动 Shell 的机器指令。在 Linux x64 下，通常是调用 </font>`<font style="color:rgb(68, 71, 70);">execve("/bin/sh", 0, 0)</font>`<font style="color:rgb(31, 31, 31);"> 系统调用。</font>

**<font style="color:rgb(31, 31, 31);">汇编实现逻辑：</font>**

1. <font style="color:rgb(31, 31, 31);">设置 RAX = 59 (syscall number for execve).</font>
2. <font style="color:rgb(31, 31, 31);">设置 RDI = 指向 "/bin/sh" 字符串的地址.</font>
3. <font style="color:rgb(31, 31, 31);">设置 RSI = 0.</font>
4. <font style="color:rgb(31, 31, 31);">设置 RDX = 0.</font>
5. <font style="color:rgb(31, 31, 31);">执行 </font>`<font style="color:rgb(68, 71, 70);">syscall</font>`<font style="color:rgb(31, 31, 31);">.</font>

### <font style="color:rgb(31, 31, 31);">6.2 利用 Pwntools 生成 Shellcode</font>
<font style="color:rgb(31, 31, 31);">手写汇编比较繁琐，Pwntools 的 </font>`<font style="color:rgb(68, 71, 70);">shellcraft</font>`<font style="color:rgb(31, 31, 31);"> 模块可以自动生成各种架构的 Shellcode 。</font>

```python
# 生成 amd64 架构下 Linux 的 sh 脚本汇编代码
sc_asm = shellcraft.amd64.linux.sh()
# 编译成机器码
shellcode = asm(sc_asm)
```

### <font style="color:rgb(31, 31, 31);">6.3 攻击策略：NOP Sled 与 JMP RSP</font>
<font style="color:rgb(31, 31, 31);">我们在栈上注入 Shellcode，但问题是：我们怎么知道 Shellcode 在栈上的确切地址？</font>

<font style="color:rgb(31, 31, 31);">栈地址在不同环境（本地 vs 远程）可能会有微小变化。</font>

**<font style="color:rgb(31, 31, 31);">方法：NOP Sled（滑雪橇）</font>**<font style="color:rgb(31, 31, 31);"> NOP（机器码 </font>`<font style="color:rgb(68, 71, 70);">0x90</font>`<font style="color:rgb(31, 31, 31);">）指令什么都不做，CPU 读到它只会执行下一条。 我们在 Shellcode 前面填充大量的 NOP。只要 RIP 跳转到 NOP 区域的任意位置，CPU 就会一路滑下去，直到执行 Shellcode </font><font style="color:rgb(31, 31, 31);">。</font>

**<font style="color:rgb(31, 31, 31);">Payload 结构：</font>**

`<font style="color:rgb(68, 71, 70);">[ NOPs (100 bytes) ] + + [ Padding ] +</font>`

<font style="color:rgb(31, 31, 31);">然而，如果开启了 ASLR，栈地址是随机的，我们无法硬编码返回地址。这时候通常需要结合寄存器。如果函数返回时，某个寄存器（如 </font>`<font style="color:rgb(68, 71, 70);">RAX</font>`<font style="color:rgb(31, 31, 31);"> 或 </font>`<font style="color:rgb(68, 71, 70);">RSP</font>`<font style="color:rgb(31, 31, 31);">）刚好指向我们的 Buffer，我们可以利用程序中自带的 </font>`<font style="color:rgb(68, 71, 70);">jmp rax</font>`<font style="color:rgb(31, 31, 31);"> 或 </font>`<font style="color:rgb(68, 71, 70);">call rax</font>`<font style="color:rgb(31, 31, 31);"> 指令（Gadget）来跳转。</font>

<font style="color:rgb(31, 31, 31);">如果可以直接泄露栈地址（例如程序打印了 Buffer 的地址），则直接填入该地址即可。</font>

---

## <font style="color:rgb(31, 31, 31);">7. 实战演练 III：Canary 绕过技术</font>
**<font style="color:rgb(31, 31, 31);">场景</font>**<font style="color:rgb(31, 31, 31);">：开启了 Stack Canary 保护。 </font>**<font style="color:rgb(31, 31, 31);">原理</font>**<font style="color:rgb(31, 31, 31);">：编译器在 Stack Frame 的 Return Address 之前插入一个随机值（Canary）。函数返回前会检查这个值是否被修改。如果我们在溢出时覆盖了它，程序会报错 </font>`<font style="color:rgb(68, 71, 70);">*** stack smashing detected ***</font>`<font style="color:rgb(31, 31, 31);"> 并终止，根本不会执行 </font>`<font style="color:rgb(68, 71, 70);">ret</font>`<font style="color:rgb(31, 31, 31);">。</font>

<font style="color:rgb(31, 31, 31);">Canary 的特点：</font>

+ <font style="color:rgb(31, 31, 31);">通常是 8 字节（64位）。</font>
+ <font style="color:rgb(31, 31, 31);">最低位字节通常是 </font>`<font style="color:rgb(68, 71, 70);">\x00</font>`<font style="color:rgb(31, 31, 31);">。这是为了防止 </font>`<font style="color:rgb(68, 71, 70);">printf</font>`<font style="color:rgb(31, 31, 31);"> 等字符串函数意外打印出 Canary（字符串遇 </font>`<font style="color:rgb(68, 71, 70);">\0</font>`<font style="color:rgb(31, 31, 31);"> 截断）。</font>

<!-- 这是一张图片，ocr 内容为： -->
![](https://cdn.nlark.com/yuque/0/2026/png/58878864/1769218949712-3c56b946-1a8d-44da-920f-f09105846337.png)

### <font style="color:rgb(31, 31, 31);">7.1 方法一：泄露 Canary (Leak)</font>
<font style="color:rgb(31, 31, 31);">如果程序存在格式化字符串漏洞，或者可以通过溢出覆盖 Canary 的最低位 </font>`<font style="color:rgb(68, 71, 70);">\x00</font>`<font style="color:rgb(31, 31, 31);">，就可以读出 Canary。</font>

**<font style="color:rgb(31, 31, 31);">覆盖截断法</font>**<font style="color:rgb(31, 31, 31);">：</font>

<font style="color:rgb(31, 31, 31);">Canary 内存如：</font>`<font style="color:rgb(68, 71, 70);">00 a1 b2 c3...</font>`

<font style="color:rgb(31, 31, 31);">如果我们溢出，刚好把第一个字节 </font>`<font style="color:rgb(68, 71, 70);">00</font>`<font style="color:rgb(31, 31, 31);"> 覆盖成 </font>`<font style="color:rgb(68, 71, 70);">61</font>`<font style="color:rgb(31, 31, 31);"> ('a')。</font>

<font style="color:rgb(31, 31, 31);">Canary 变为：</font>`<font style="color:rgb(68, 71, 70);">61 a1 b2 c3...</font>`

<font style="color:rgb(31, 31, 31);">此时调用 </font>`<font style="color:rgb(68, 71, 70);">printf("%s", buffer)</font>`<font style="color:rgb(31, 31, 31);">，因为没有了 </font>`<font style="color:rgb(68, 71, 70);">\0</font>`<font style="color:rgb(31, 31, 31);"> 截断，</font>`<font style="color:rgb(68, 71, 70);">printf</font>`<font style="color:rgb(31, 31, 31);"> 会连着 Buffer 把后面的 Canary 也打印出来。</font>

<font style="color:rgb(31, 31, 31);">获取到 Canary 后，我们在构造 Payload 时，将正确的值填回去，就能骗过检查。</font>

### <font style="color:rgb(31, 31, 31);">7.2 方法二：爆破 (Brute-force)</font>
**<font style="color:rgb(31, 31, 31);">适用场景</font>**<font style="color:rgb(31, 31, 31);">：服务器使用 </font>`<font style="color:rgb(68, 71, 70);">fork()</font>`<font style="color:rgb(31, 31, 31);"> 处理网络请求。</font>

**<font style="color:rgb(31, 31, 31);">原理</font>**<font style="color:rgb(31, 31, 31);">：</font>`<font style="color:rgb(68, 71, 70);">fork()</font>`<font style="color:rgb(31, 31, 31);"> 出来的子进程会完全拷贝父进程的内存，包括 Canary。这意味着每次连接的 Canary 都是一样的。</font>

<font style="color:rgb(31, 31, 31);">我们可以逐个字节地猜。</font>

+ <font style="color:rgb(31, 31, 31);">先猜第 1 个字节（已知是 0x00，但如果是 Windows 或特殊环境可能不同）。</font>
+ <font style="color:rgb(31, 31, 31);">猜第 2 个字节：发送 0x00，如果不崩溃，说明猜对；如果崩溃（Socket 断开），说明猜错，试 0x01...</font>
+ <font style="color:rgb(31, 31, 31);">猜出第 2 个字节后，固定它，继续猜第 3 个。</font>
+ <font style="color:rgb(31, 31, 31);">最多尝试 256 * 7 次即可拿到完整 Canary。这比暴力穷举 64 位数值要快得多 </font><font style="color:rgb(31, 31, 31);">。</font>

还有格式化字符串直接读取canary

---

## <font style="color:rgb(31, 31, 31);">8. 实战演练 IV：Ret2Syscall 与 ROP（无后门、NX 开启）</font>
+ **<font style="color:rgb(31, 31, 31);">NX Enabled</font>**<font style="color:rgb(31, 31, 31);">: 无法执行 Shellcode。</font>
+ **<font style="color:rgb(31, 31, 31);">No "Win" Function</font>**<font style="color:rgb(31, 31, 31);">: 必须自己构造系统调用。</font>
+ **<font style="color:rgb(31, 31, 31);">Static Link</font>**<font style="color:rgb(31, 31, 31);"> (静态链接) 或 </font>**<font style="color:rgb(31, 31, 31);">Ret2Libc</font>**<font style="color:rgb(31, 31, 31);"> (动态链接)。这里先讲最基础的利用程序自身 Gadget 的 Ret2Syscall。</font>

### <font style="color:rgb(31, 31, 31);">8.1 ROP (Return Oriented Programming) 原理</font>
<font style="color:rgb(31, 31, 31);">既然不能写入新代码，我们就复用程序里已有的代码片段。这些片段以 </font>`<font style="color:rgb(68, 71, 70);">ret</font>`<font style="color:rgb(31, 31, 31);"> 结尾，称为 </font>**<font style="color:rgb(31, 31, 31);">Gadget</font>**<font style="color:rgb(31, 31, 31);">。 通过精心排列栈上的返回地址，我们可以让 CPU 在执行完一个 Gadget 后，跳到下一个 Gadget，像拼积木一样拼出复杂的逻辑。(我们通过写rop链设置寄存器。然后调用system函数完成题目)</font>

### <font style="color:rgb(31, 31, 31);">8.2 目标：拼凑 execve 系统调用</font>
<font style="color:rgb(31, 31, 31);">我们需要寻找以下 Gadgets（使用 </font>`<font style="color:rgb(68, 71, 70);">ROPgadget</font>`<font style="color:rgb(31, 31, 31);"> 或 </font>`<font style="color:rgb(68, 71, 70);">ropper</font>`<font style="color:rgb(31, 31, 31);"> 工具）：</font>

1. `<font style="color:rgb(68, 71, 70);">pop rdi; ret</font>`<font style="color:rgb(31, 31, 31);"> ：用于设置 RDI 寄存器。</font>
2. `<font style="color:rgb(68, 71, 70);">pop rsi; ret</font>`<font style="color:rgb(31, 31, 31);"> ：用于设置 RSI 寄存器。</font>
3. `<font style="color:rgb(68, 71, 70);">pop rdx; ret</font>`<font style="color:rgb(31, 31, 31);"> ：用于设置 RDX 寄存器。</font>
4. `<font style="color:rgb(68, 71, 70);">pop rax; ret</font>`<font style="color:rgb(31, 31, 31);"> ：用于设置 RAX 寄存器。</font>
5. `<font style="color:rgb(68, 71, 70);">syscall; ret</font>`<font style="color:rgb(31, 31, 31);"> ：触发系统调用。</font>
6. <font style="color:rgb(31, 31, 31);">寻找的指令：</font>

```bash
ROPgadget --binary ret2libc1（自己的文件名） --only "pop|ret" |grep  'rdi'
//这里查询rdi为例//
```

<font style="color:rgb(31, 31, 31);">此外，我们需要一个地址存放字符串 "/bin/sh"。可以使用程序中已有的（.data 段），或者利用 </font>`<font style="color:rgb(68, 71, 70);">read</font>`<font style="color:rgb(31, 31, 31);"> 函数写一段进去。</font>

### <font style="color:rgb(31, 31, 31);">8.3 ROP 链构造流程</font>
<font style="color:rgb(31, 31, 31);">假设我们找到了所有 Gadgets，且地址 </font>`<font style="color:rgb(68, 71, 70);">0x404000</font>`<font style="color:rgb(31, 31, 31);"> 处有 "/bin/sh" 字符串。</font>

**<font style="color:rgb(31, 31, 31);">栈布局（Payload）设计：</font>**

1. **<font style="color:rgb(31, 31, 31);">Padding</font>**<font style="color:rgb(31, 31, 31);">: 填充溢出偏移。</font>
2. **<font style="color:rgb(31, 31, 31);">Gadget 1 Addr</font>**<font style="color:rgb(31, 31, 31);"> (</font>`<font style="color:rgb(68, 71, 70);">pop rax; ret</font>`<font style="color:rgb(31, 31, 31);">)</font>
3. **<font style="color:rgb(31, 31, 31);">Value</font>**<font style="color:rgb(31, 31, 31);">: 59 (0x3b) -> 弹入 RAX</font>
4. **<font style="color:rgb(31, 31, 31);">Gadget 2 Addr</font>**<font style="color:rgb(31, 31, 31);"> (</font>`<font style="color:rgb(68, 71, 70);">pop rdi; ret</font>`<font style="color:rgb(31, 31, 31);">)</font>
5. **<font style="color:rgb(31, 31, 31);">Value</font>**<font style="color:rgb(31, 31, 31);">: 0x404000 (ptr to "/bin/sh") -> 弹入 RDI</font>
6. **<font style="color:rgb(31, 31, 31);">Gadget 3 Addr</font>**<font style="color:rgb(31, 31, 31);"> (</font>`<font style="color:rgb(68, 71, 70);">pop rsi; ret</font>`<font style="color:rgb(31, 31, 31);">)</font>
7. **<font style="color:rgb(31, 31, 31);">Value</font>**<font style="color:rgb(31, 31, 31);">: 0 -> 弹入 RSI</font>
8. **<font style="color:rgb(31, 31, 31);">Gadget 4 Addr</font>**<font style="color:rgb(31, 31, 31);"> (</font>`<font style="color:rgb(68, 71, 70);">pop rdx; ret</font>`<font style="color:rgb(31, 31, 31);">)</font>
9. **<font style="color:rgb(31, 31, 31);">Value</font>**<font style="color:rgb(31, 31, 31);">: 0 -> 弹入 RDX</font>
10. **<font style="color:rgb(31, 31, 31);">Gadget 5 Addr</font>**<font style="color:rgb(31, 31, 31);"> (</font>`<font style="color:rgb(68, 71, 70);">syscall</font>`<font style="color:rgb(31, 31, 31);">)</font>

<font style="color:rgb(31, 31, 31);">当函数返回时，它会依次执行上述指令，最终触发 </font>`<font style="color:rgb(68, 71, 70);">execve("/bin/sh", 0, 0)</font>`<font style="color:rgb(31, 31, 31);">，获取 Shell </font><font style="color:rgb(31, 31, 31);">。</font>



<font style="color:rgb(31, 31, 31);">Pwntools 提供了极其强大的 ROP 模块，可以自动寻找 Gadgets 并构建链条（但是一般还是需要自己写）：</font>

```python
elf = ELF('./rop_challenge')
rop = ROP(elf)

# 假设程序中已经有了 /bin/sh 字符串
bin_sh_addr = next(elf.search(b'/bin/sh'))

# 自动生成调用 execve('/bin/sh', 0, 0) 的链
rop.execve(bin_sh_addr, 0, 0)

print(rop.dump()) # 打印生成的 ROP 链结构

payload = b'A' * offset + rop.chain()
p.sendline(payload)
```

<font style="color:rgb(31, 31, 31);">如果程序是动态链接且没有静态的 </font>`<font style="color:rgb(68, 71, 70);">syscall</font>`<font style="color:rgb(31, 31, 31);"> 片段，我们需要使用 </font>**<font style="color:rgb(31, 31, 31);">Ret2Libc</font>**<font style="color:rgb(31, 31, 31);"> 技术：先泄露 </font>`<font style="color:rgb(68, 71, 70);">puts</font>`<font style="color:rgb(31, 31, 31);"> 或 </font>`<font style="color:rgb(68, 71, 70);">write</font>`<font style="color:rgb(31, 31, 31);"> 的真实地址，计算出 </font>`<font style="color:rgb(68, 71, 70);">libc</font>`<font style="color:rgb(31, 31, 31);"> 的基地址，再调用 </font>`<font style="color:rgb(68, 71, 70);">libc</font>`<font style="color:rgb(31, 31, 31);"> 中的 </font>`<font style="color:rgb(68, 71, 70);">system</font>`<font style="color:rgb(31, 31, 31);"> 函数。这属于更进阶的内容，但在逻辑上依然是 ROP 的一种应用。</font>

---

### <font style="color:rgb(31, 31, 31);">9 知识图谱回顾</font>
+ **<font style="color:rgb(31, 31, 31);">核心原理</font>**<font style="color:rgb(31, 31, 31);">：栈帧的 LIFO 结构、Return Address 的关键作用。</font>
+ **<font style="color:rgb(31, 31, 31);">工具使用</font>**<font style="color:rgb(31, 31, 31);">：GDB 动态调试查看内存，Pwntools 编写 Exploit。</font>
+ **<font style="color:rgb(31, 31, 31);">攻击演进</font>**<font style="color:rgb(31, 31, 31);">：</font>
    - <font style="color:rgb(31, 31, 31);">简单的 Ret2Text（修改返回地址）。</font>
    - <font style="color:rgb(31, 31, 31);">Shellcode 注入（针对 NX 关闭）。</font>
    - <font style="color:rgb(31, 31, 31);">Canary 绕过（泄露与爆破）。</font>
    - <font style="color:rgb(31, 31, 31);">ROP / Ret2Syscall（针对 NX 开启）。</font>

### <font style="color:rgb(31, 31, 31);"> 进阶学习路线</font>
<font style="color:rgb(31, 31, 31);">栈溢出仅仅是二进制安全的冰山一角。掌握上述内容后，建议继续探索：</font>

1. **<font style="color:rgb(31, 31, 31);">Ret2Libc & GOT/PLT Hijacking</font>**<font style="color:rgb(31, 31, 31);">：应对 ASLR 和动态链接的标准解法 </font><font style="color:rgb(31, 31, 31);">。</font>
2. **<font style="color:rgb(31, 31, 31);">堆漏洞（Heap Exploitation）</font>**<font style="color:rgb(31, 31, 31);">：</font>`<font style="color:rgb(68, 71, 70);">malloc</font>`<font style="color:rgb(31, 31, 31);"> 和 </font>`<font style="color:rgb(68, 71, 70);">free</font>`<font style="color:rgb(31, 31, 31);"> 的机制极其复杂，涉及 Use-After-Free (UAF)、Double Free、Heap Overflow 等，是现代 Pwn 的主流 </font><font style="color:rgb(31, 31, 31);">。</font>
3. **<font style="color:rgb(31, 31, 31);">格式化字符串漏洞（Format String）</font>**<font style="color:rgb(31, 31, 31);">：利用 </font>`<font style="color:rgb(68, 71, 70);">printf</font>`<font style="color:rgb(31, 31, 31);"> 实现任意内存读写 。</font>

<font style="color:rgb(31, 31, 31);"></font>

